let url = window.location.pathname;
let path = 'app/prefabs/Firebase_push_notifications/resources/firebase-dependencies/'
let swPath = url + path + 'firebase-messaging-sw.js';
let pushScope = url + path + 'firebase-cloud-messaging-push-scope';

! function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(require("@firebase/app-compat"), require("@firebase/app")) : "function" == typeof define && define.amd ? define(["@firebase/app-compat", "@firebase/app"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).firebase, e.firebase.INTERNAL.modularAPIs)
}(this, function(kt, It) {
    "use strict";
    try {
        ! function() {
            var i, e = (e = kt) && "object" == typeof e && "default" in e ? e : {
                default: e
            };

            function x() {
                try {
                    return "object" == typeof indexedDB
                } catch (e) {
                    return !1
                }
            }
            class a extends Error {
                constructor(e, t, n) {
                    super(t), this.code = e, this.customData = n, this.name = "FirebaseError", Object.setPrototypeOf(this, a.prototype), Error.captureStackTrace && Error.captureStackTrace(this, r.prototype.create)
                }
            }
            class r {
                constructor(e, t, n) {
                    this.service = e, this.serviceName = t, this.errors = n
                }
                create(e, ...t) {
                    var i, t = t[0] || {},
                        n = this.service + "/" + e,
                        e = (e = this.errors[e]) ? (i = t, e.replace(L, (e, t) => {
                            var n = i[t];
                            return null != n ? String(n) : `<${t}?>`
                        })) : "Error",
                        e = this.serviceName + `: ${e} (${n}).`;
                    return new a(n, e, t)
                }
            }
            const L = /\{\$([^}]+)}/g;

            function o(e) {
                return e && e._delegate ? e._delegate : e
            }
            class t {
                constructor(e, t, n) {
                    this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null
                }
                setInstantiationMode(e) {
                    return this.instantiationMode = e, this
                }
                setMultipleInstances(e) {
                    return this.multipleInstances = e, this
                }
                setServiceProps(e) {
                    return this.serviceProps = e, this
                }
                setInstanceCreatedCallback(e) {
                    return this.onInstanceCreated = e, this
                }
            }
            const B = (t, e) => e.some(e => t instanceof e);
            let F, H;
            const R = new WeakMap,
                s = new WeakMap,
                q = new WeakMap,
                n = new WeakMap,
                c = new WeakMap;
            let p = {
                get(e, t, n) {
                    if (e instanceof IDBTransaction) {
                        if ("done" === t) return s.get(e);
                        if ("objectStoreNames" === t) return e.objectStoreNames || q.get(e);
                        if ("store" === t) return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
                    }
                    return d(e[t])
                },
                set(e, t, n) {
                    return e[t] = n, !0
                },
                has(e, t) {
                    return e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e
                }
            };

            function V(e) {
                return "function" == typeof e ? (n = e) !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? (H = H || [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]).includes(n) ? function(...e) {
                    return n.apply(u(this), e), d(R.get(this))
                } : function(...e) {
                    return d(n.apply(u(this), e))
                } : function(e, ...t) {
                    t = n.call(u(this), e, ...t);
                    return q.set(t, e.sort ? e.sort() : [e]), d(t)
                } : (e instanceof IDBTransaction && (r = e, s.has(r) || (t = new Promise((e, t) => {
                    const n = () => {
                            r.removeEventListener("complete", i), r.removeEventListener("error", a), r.removeEventListener("abort", a)
                        },
                        i = () => {
                            e(), n()
                        },
                        a = () => {
                            t(r.error || new DOMException("AbortError", "AbortError")), n()
                        };
                    r.addEventListener("complete", i), r.addEventListener("error", a), r.addEventListener("abort", a)
                }), s.set(r, t))), B(e, F = F || [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]) ? new Proxy(e, p) : e);
                var n, r, t
            }

            function d(e) {
                var r, t;
                return e instanceof IDBRequest ? (r = e, (t = new Promise((e, t) => {
                    const n = () => {
                            r.removeEventListener("success", i), r.removeEventListener("error", a)
                        },
                        i = () => {
                            e(d(r.result)), n()
                        },
                        a = () => {
                            t(r.error), n()
                        };
                    r.addEventListener("success", i), r.addEventListener("error", a)
                })).then(e => {
                    e instanceof IDBCursor && R.set(e, r)
                }).catch(() => {}), c.set(t, r), t) : n.has(e) ? n.get(e) : ((t = V(e)) !== e && (n.set(e, t), c.set(t, e)), t)
            }
            const u = e => c.get(e);

            function l(e, t, {
                blocked: n,
                upgrade: i,
                blocking: a,
                terminated: r
            } = {}) {
                const o = indexedDB.open(e, t),
                    s = d(o);
                return i && o.addEventListener("upgradeneeded", e => {
                    i(d(o.result), e.oldVersion, e.newVersion, d(o.transaction), e)
                }), n && o.addEventListener("blocked", e => n(e.oldVersion, e.newVersion, e)), s.then(e => {
                    r && e.addEventListener("close", () => r()), a && e.addEventListener("versionchange", e => a(e.oldVersion, e.newVersion, e))
                }).catch(() => {}), s
            }

            function f(e, {
                blocked: t
            } = {}) {
                e = indexedDB.deleteDatabase(e);
                return t && e.addEventListener("blocked", e => t(e.oldVersion, e)), d(e).then(() => {})
            }
            const W = ["get", "getKey", "getAll", "getAllKeys", "count"],
                $ = ["put", "add", "delete", "clear"],
                g = new Map;

            function U(e, t) {
                if (e instanceof IDBDatabase && !(t in e) && "string" == typeof t) {
                    if (g.get(t)) return g.get(t);
                    const i = t.replace(/FromIndex$/, ""),
                        a = t !== i,
                        r = $.includes(i);
                    return i in (a ? IDBIndex : IDBObjectStore).prototype && (r || W.includes(i)) ? (e = async function(e, ...t) {
                        e = this.transaction(e, r ? "readwrite" : "readonly");
                        let n = e.store;
                        return a && (n = n.index(t.shift())), (await Promise.all([n[i](...t), r && e.done]))[0]
                    }, g.set(t, e), e) : void 0
                }
            }
            p = { ...i = p,
                get: (e, t, n) => U(e, t) || i.get(e, t, n),
                has: (e, t) => !!U(e, t) || i.has(e, t)
            };
            var w, h, m, b, v = "@firebase/installations",
                y = "0.6.4";
            const G = 1e4,
                J = "w:" + y,
                z = "FIS_v2",
                Y = "https://firebaseinstallations.googleapis.com/v1",
                Q = 36e5,
                k = new r("installations", "Installations", {
                    "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
                    "not-registered": "Firebase Installation is not registered.",
                    "installation-not-found": "Firebase Installation not found.",
                    "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
                    "app-offline": "Could not process request. Application offline.",
                    "delete-pending-registration": "Can't delete installation while there is a pending registration request."
                });

            function Z(e) {
                return e instanceof a && e.code.includes("request-failed")
            }

            function X({
                projectId: e
            }) {
                return Y + `/projects/${e}/installations`
            }

            function ee(e) {
                return {
                    token: e.token,
                    requestStatus: 2,
                    expiresIn: (e = e.expiresIn, Number(e.replace("s", "000"))),
                    creationTime: Date.now()
                }
            }
            async function te(e, t) {
                t = (await t.json()).error;
                return k.create("request-failed", {
                    requestName: e,
                    serverCode: t.code,
                    serverMessage: t.message,
                    serverStatus: t.status
                })
            }

            function ne({
                apiKey: e
            }) {
                return new Headers({
                    "Content-Type": "application/json",
                    Accept: "application/json",
                    "x-goog-api-key": e
                })
            }
            async function ie(e) {
                var t = await e();
                return 500 <= t.status && t.status < 600 ? e() : t
            }

            function ae(t) {
                return new Promise(e => {
                    setTimeout(e, t)
                })
            }
            const re = /^[cdef][\w-]{21}$/,
                I = "";

            function S(e) {
                return e.appName + "!" + e.appId
            }
            const oe = new Map;

            function se(e, t) {
                var n, e = S(e);
                ce(e, t), e = e, t = t, !T && "BroadcastChannel" in self && ((T = new BroadcastChannel("[Firebase] FID Change")).onmessage = e => {
                    ce(e.data.key, e.data.fid)
                }), (n = T) && n.postMessage({
                    key: e,
                    fid: t
                }), 0 === oe.size && T && (T.close(), T = null)
            }

            function ce(e, t) {
                e = oe.get(e);
                if (e)
                    for (const n of e) n(t)
            }
            let T = null;
            const C = "firebase-installations-store";
            let pe = null;

            function D() {
                return pe = pe || l("firebase-installations-database", 1, {
                    upgrade: (e, t) => {
                        0 === t && e.createObjectStore(C)
                    }
                })
            }
            async function _(e, t) {
                var n = S(e),
                    i = (await D()).transaction(C, "readwrite"),
                    a = i.objectStore(C),
                    r = await a.get(n);
                return await a.put(t, n), await i.done, r && r.fid === t.fid || se(e, t.fid), t
            }
            async function de(e) {
                var e = S(e),
                    t = (await D()).transaction(C, "readwrite");
                await t.objectStore(C).delete(e), await t.done
            }
            async function j(e, t) {
                var n = S(e),
                    i = (await D()).transaction(C, "readwrite"),
                    a = i.objectStore(C),
                    r = await a.get(n),
                    t = t(r);
                return void 0 === t ? await a.delete(n) : await a.put(t, n), await i.done, !t || r && r.fid === t.fid || se(e, t.fid), t
            }
            async function O(a) {
                let r;
                var e = await j(a.appConfig, e => {
                    var t, n, i, e = le(e || {
                            fid: function() {
                                try {
                                    var e = new Uint8Array(17),
                                        t = ((self.crypto || self.msCrypto).getRandomValues(e), e[0] = 112 + e[0] % 16, n = e, btoa(String.fromCharCode(...n)).replace(/\+/g, "-").replace(/\//g, "_").substr(0, 22));
                                    return re.test(t) ? t : I
                                } catch (t) {
                                    return I
                                }
                                var n
                            }(),
                            registrationStatus: 0
                        }),
                        e = (t = a, 0 !== (n = e).registrationStatus ? 1 === n.registrationStatus ? {
                            installationEntry: n,
                            registrationPromise: async function(e) {
                                let t = await ue(e.appConfig);
                                for (; 1 === t.registrationStatus;) await ae(100), t = await ue(e.appConfig);
                                var n, i;
                                return 0 !== t.registrationStatus ? t : ({
                                    installationEntry: n,
                                    registrationPromise: i
                                } = await O(e), i || n)
                            }(t)
                        } : {
                            installationEntry: n
                        } : navigator.onLine ? {
                            installationEntry: i = {
                                fid: n.fid,
                                registrationStatus: 1,
                                registrationTime: Date.now()
                            },
                            registrationPromise: async function(e, t) {
                                try {
                                    var n = await async function({
                                        appConfig: e,
                                        heartbeatServiceProvider: t
                                    }, {
                                        fid: n
                                    }) {
                                        const i = X(e),
                                            a = ne(e),
                                            r = t.getImmediate({
                                                optional: !0
                                            });
                                        r && (o = await r.getHeartbeatsHeader()) && a.append("x-firebase-client", o);
                                        var o = {
                                            fid: n,
                                            authVersion: z,
                                            appId: e.appId,
                                            sdkVersion: J
                                        };
                                        const s = {
                                                method: "POST",
                                                headers: a,
                                                body: JSON.stringify(o)
                                            },
                                            c = await ie(() => fetch(i, s));
                                        if (c.ok) return {
                                            fid: (o = await c.json()).fid || n,
                                            registrationStatus: 2,
                                            refreshToken: o.refreshToken,
                                            authToken: ee(o.authToken)
                                        };
                                        throw await te("Create Installation", c)
                                    }(e, t);
                                    return _(e.appConfig, n)
                                } catch (n) {
                                    throw Z(n) && 409 === n.customData.serverCode ? await de(e.appConfig) : await _(e.appConfig, {
                                        fid: t.fid,
                                        registrationStatus: 0
                                    }), n
                                }
                            }(t, i)
                        } : {
                            installationEntry: n,
                            registrationPromise: Promise.reject(k.create("app-offline"))
                        });
                    return r = e.registrationPromise, e.installationEntry
                });
                return e.fid === I ? {
                    installationEntry: await r
                } : {
                    installationEntry: e,
                    registrationPromise: r
                }
            }

            function ue(e) {
                return j(e, e => {
                    if (e) return le(e);
                    throw k.create("installation-not-found")
                })
            }

            function le(e) {
                return 1 === e.registrationStatus && e.registrationTime + G < Date.now() ? {
                    fid: e.fid,
                    registrationStatus: 0
                } : e
            }
            async function fe({
                appConfig: e,
                heartbeatServiceProvider: t
            }, n) {
                [a, r] = [e, n.fid];
                const i = X(a) + `/${r}/authTokens:generate`;
                [a, r] = [e, n.refreshToken], (a = ne(a)).append("Authorization", z + " " + r);
                var a, n = a,
                    r = t.getImmediate({
                        optional: !0
                    }),
                    o = (r && (o = await r.getHeartbeatsHeader()) && n.append("x-firebase-client", o), {
                        installation: {
                            sdkVersion: J,
                            appId: e.appId
                        }
                    });
                const s = {
                        method: "POST",
                        headers: n,
                        body: JSON.stringify(o)
                    },
                    c = await ie(() => fetch(i, s));
                if (c.ok) return ee(await c.json());
                throw await te("Generate Auth Token", c)
            }
            async function ge(r, o = !1) {
                let s;
                var e = await j(r.appConfig, e => {
                    if (!he(e)) throw k.create("not-registered");
                    var t, n, i, a = e.authToken;
                    if (o || 2 !== (t = a).requestStatus || (n = t, (i = Date.now()) < n.creationTime) || n.creationTime + n.expiresIn < i + Q) {
                        if (1 === a.requestStatus) return s = async function(e, t) {
                            let n = await we(e.appConfig);
                            for (; 1 === n.authToken.requestStatus;) await ae(100), n = await we(e.appConfig);
                            var i = n.authToken;
                            return 0 === i.requestStatus ? ge(e, t) : i
                        }(r, o), e;
                        if (navigator.onLine) return t = e, a = {
                            requestStatus: 1,
                            requestTime: Date.now()
                        }, a = Object.assign(Object.assign({}, t), {
                            authToken: a
                        }), s = async function(e, t) {
                            try {
                                var n = await fe(e, t),
                                    i = Object.assign(Object.assign({}, t), {
                                        authToken: n
                                    });
                                return await _(e.appConfig, i), n
                            } catch (i) {
                                throw !Z(i) || 401 !== i.customData.serverCode && 404 !== i.customData.serverCode ? (n = Object.assign(Object.assign({}, t), {
                                    authToken: {
                                        requestStatus: 0
                                    }
                                }), await _(e.appConfig, n)) : await de(e.appConfig), i
                            }
                        }(r, a), a;
                        throw k.create("app-offline")
                    }
                    return e
                });
                return s ? await s : e.authToken
            }

            function we(e) {
                return j(e, e => {
                    var t;
                    if (he(e)) return 1 === (t = e.authToken).requestStatus && t.requestTime + G < Date.now() ? Object.assign(Object.assign({}, e), {
                        authToken: {
                            requestStatus: 0
                        }
                    }) : e;
                    throw k.create("not-registered")
                })
            }

            function he(e) {
                return void 0 !== e && 2 === e.registrationStatus
            }

            function me(e) {
                return k.create("missing-app-config-values", {
                    valueName: e
                })
            }
            const be = "installations",
                ve = (It._registerComponent(new t(be, e => {
                    e = e.getProvider("app").getImmediate();
                    return {
                        app: e,
                        appConfig: function(e) {
                            if (!e || !e.options) throw me("App Configuration");
                            if (!e.name) throw me("App Name");
                            for (const t of ["projectId", "apiKey", "appId"])
                                if (!e.options[t]) throw me(t);
                            return {
                                appName: e.name,
                                projectId: e.options.projectId,
                                apiKey: e.options.apiKey,
                                appId: e.options.appId
                            }
                        }(e),
                        heartbeatServiceProvider: It._getProvider(e, "heartbeat"),
                        _delete: () => Promise.resolve()
                    }
                }, "PUBLIC")), It._registerComponent(new t("installations-internal", e => {
                    e = e.getProvider("app").getImmediate();
                    const t = It._getProvider(e, be).getImmediate();
                    return {
                        getId: () => async function(e) {
                            var {
                                installationEntry: t,
                                registrationPromise: n
                            } = await O(e);
                            return (n || ge(e)).catch(console.error), t.fid
                        }(t),
                        getToken: e => async function(e, t = !1) {
                            var n;
                            return await ((n = (await O(e)).registrationPromise) && await n), (await ge(e, t)).token
                        }(t, e)
                    }
                }, "PRIVATE")), It.registerVersion(v, y), It.registerVersion(v, y, "esm2017"), swPath),
                ye = pushScope,
                ke = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4",
                Ie = "https://fcmregistrations.googleapis.com/v1",
                Se = "google.c.a.c_id",
                Te = "google.c.a.e";

            function P(e) {
                e = new Uint8Array(e);
                return btoa(String.fromCharCode(...e)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
            }(v = b = b || {})[v.DATA_MESSAGE = 1] = "DATA_MESSAGE", v[v.DISPLAY_NOTIFICATION = 3] = "DISPLAY_NOTIFICATION", (b = w = w || {}).PUSH_RECEIVED = "push-received", b.NOTIFICATION_CLICKED = "notification-clicked";
            const Ce = "fcm_token_details_db",
                De = "fcm_token_object_Store";
            const _e = "firebase-messaging-database",
                je = 1,
                E = "firebase-messaging-store";
            let Oe = null;

            function Pe() {
                return Oe = Oe || l(_e, je, {
                    upgrade: (e, t) => {
                        0 === t && e.createObjectStore(E)
                    }
                })
            }
            async function Ee(e) {
                var t = Ae(e);
                return (t = await (await Pe()).transaction(E).objectStore(E).get(t)) || ((t = await async function(r) {
                    if ("databases" in indexedDB && !(await indexedDB.databases()).map(e => e.name).includes(Ce)) return null;
                    let o = null;
                    return (await l(Ce, 5, {
                            upgrade: async(e, t, n, i) => {
                                var a;
                                t < 2 || !e.objectStoreNames.contains(De) || (i = await (e = i.objectStore(De)).index("fcmSenderId").get(r), await e.clear(), i && (2 === t ? (a = i).auth && a.p256dh && a.endpoint && (o = {
                                    token: a.fcmToken,
                                    createTime: null != (e = a.createTime) ? e : Date.now(),
                                    subscriptionOptions: {
                                        auth: a.auth,
                                        p256dh: a.p256dh,
                                        endpoint: a.endpoint,
                                        swScope: a.swScope,
                                        vapidKey: "string" == typeof a.vapidKey ? a.vapidKey : P(a.vapidKey)
                                    }
                                }) : 3 === t ? (a = i, o = {
                                    token: a.fcmToken,
                                    createTime: a.createTime,
                                    subscriptionOptions: {
                                        auth: P(a.auth),
                                        p256dh: P(a.p256dh),
                                        endpoint: a.endpoint,
                                        swScope: a.swScope,
                                        vapidKey: P(a.vapidKey)
                                    }
                                }) : 4 === t && (o = {
                                    token: i.fcmToken,
                                    createTime: i.createTime,
                                    subscriptionOptions: {
                                        auth: P(i.auth),
                                        p256dh: P(i.p256dh),
                                        endpoint: i.endpoint,
                                        swScope: i.swScope,
                                        vapidKey: P(i.vapidKey)
                                    }
                                })))
                            }
                        })).close(), await f(Ce), await f("fcm_vapid_details_db"), await f("undefined"),
                        function(e) {
                            var t;
                            if (e && e.subscriptionOptions) return t = e.subscriptionOptions, "number" == typeof e.createTime && 0 < e.createTime && "string" == typeof e.token && 0 < e.token.length && "string" == typeof t.auth && 0 < t.auth.length && "string" == typeof t.p256dh && 0 < t.p256dh.length && "string" == typeof t.endpoint && 0 < t.endpoint.length && "string" == typeof t.swScope && 0 < t.swScope.length && "string" == typeof t.vapidKey && 0 < t.vapidKey.length
                        }(o) ? o : null
                }(e.appConfig.senderId)) ? (await Me(e, t), t) : void 0)
            }
            async function Me(e, t) {
                var e = Ae(e),
                    n = (await Pe()).transaction(E, "readwrite");
                return await n.objectStore(E).put(t, e), await n.done, t
            }

            function Ae({
                appConfig: e
            }) {
                return e.appId
            }
            const M = new r("messaging", "Messaging", {
                "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
                "only-available-in-window": "This method is available in a Window context.",
                "only-available-in-sw": "This method is available in a service worker context.",
                "permission-default": "The notification permission was not granted and dismissed instead.",
                "permission-blocked": "The notification permission was not granted and blocked instead.",
                "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.",
                "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
                "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}",
                "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}",
                "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.",
                "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
                "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}",
                "token-update-no-token": "FCM returned no token when updating the user to push.",
                "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
                "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
                "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.",
                "invalid-vapid-key": "The public VAPID key must be a string.",
                "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
            });
            async function Ke(e, t) {
                var n = {
                    method: "DELETE",
                    headers: await xe(e)
                };
                try {
                    var i, a = await (await fetch(Ne(e.appConfig) + "/" + t, n)).json();
                    if (a.error) throw i = a.error.message, M.create("token-unsubscribe-failed", {
                        errorInfo: i
                    })
                } catch (e) {
                    throw M.create("token-unsubscribe-failed", {
                        errorInfo: null == e ? void 0 : e.toString()
                    })
                }
            }

            function Ne({
                projectId: e
            }) {
                return Ie + `/projects/${e}/registrations`
            }
            async function xe({
                appConfig: e,
                installations: t
            }) {
                t = await t.getToken();
                return new Headers({
                    "Content-Type": "application/json",
                    Accept: "application/json",
                    "x-goog-api-key": e.apiKey,
                    "x-goog-firebase-installations-auth": "FIS " + t
                })
            }

            function Le({
                p256dh: e,
                auth: t,
                endpoint: n,
                vapidKey: i
            }) {
                n = {
                    web: {
                        endpoint: n,
                        auth: t,
                        p256dh: e
                    }
                };
                return i !== ke && (n.web.applicationPubKey = i), n
            }
            const Be = 6048e5;
            async function Fe(e) {
                var t, n = await Ee(e.firebaseDependencies),
                    n = (n && (await Ke(e.firebaseDependencies, n.token), n = Ae(n = e.firebaseDependencies), await (t = (await Pe()).transaction(E, "readwrite")).objectStore(E).delete(n), await t.done), await e.swRegistration.pushManager.getSubscription());
                return !n || n.unsubscribe()
            }
            async function He(e, t) {
                t = {
                    token: await async function(e, t) {
                        var n = await xe(e),
                            t = Le(t),
                            t = {
                                method: "POST",
                                headers: n,
                                body: JSON.stringify(t)
                            };
                        let i;
                        try {
                            var a = await fetch(Ne(e.appConfig), t);
                            i = await a.json()
                        } catch (e) {
                            throw M.create("token-subscribe-failed", {
                                errorInfo: null == e ? void 0 : e.toString()
                            })
                        }
                        if (i.error) throw t = i.error.message, M.create("token-subscribe-failed", {
                            errorInfo: t
                        });
                        if (i.token) return i.token;
                        throw M.create("token-subscribe-no-token")
                    }(e, t),
                    createTime: Date.now(),
                    subscriptionOptions: t
                };
                return await Me(e, t), t.token
            }

            function Re(e) {
                var t, n, i, a, r = {
                        from: e.from,
                        collapseKey: e.collapse_key,
                        messageId: e.fcmMessageId
                    },
                    o = r;
                return (n = e).notification && (o.notification = {}, (t = n.notification.title) && (o.notification.title = t), (t = n.notification.body) && (o.notification.body = t), (t = n.notification.image) && (o.notification.image = t), t = n.notification.icon) && (o.notification.icon = t), n = r, (o = e).data && (n.data = o.data), o = r, (e.fcmOptions || null != (i = e.notification) && i.click_action) && (o.fcmOptions = {}, (a = null != (i = null == (i = e.fcmOptions) ? void 0 : i.link) ? i : null == (a = e.notification) ? void 0 : a.click_action) && (o.fcmOptions.link = a), a = null == (a = e.fcmOptions) ? void 0 : a.analytics_label) && (o.fcmOptions.analyticsLabel = a), r
            }

            function qe(t, n) {
                var i = [];
                for (let e = 0; e < t.length; e++) i.push(t.charAt(e)), e < n.length && i.push(n.charAt(e));
                i.join("")
            }

            function Ve(e) {
                return M.create("missing-app-config-values", {
                    valueName: e
                })
            }
            qe("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o"), qe("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");
            class We {
                constructor(e, t, n) {
                    this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1;
                    var i = function(e) {
                        if (!e || !e.options) throw Ve("App Configuration Object");
                        if (!e.name) throw Ve("App Name");
                        var t = e.options;
                        for (const n of ["projectId", "apiKey", "appId", "messagingSenderId"])
                            if (!t[n]) throw Ve(n);
                        return {
                            appName: e.name,
                            projectId: t.projectId,
                            apiKey: t.apiKey,
                            appId: t.appId,
                            senderId: t.messagingSenderId
                        }
                    }(e);
                    this.firebaseDependencies = {
                        app: e,
                        appConfig: i,
                        installations: t,
                        analyticsProvider: n
                    }
                }
                _delete() {
                    return Promise.resolve()
                }
            }
            async function $e(e) {
                try {
                    e.swRegistration = await navigator.serviceWorker.register(ve, {
                        scope: ye
                    }), e.swRegistration.update().catch(() => {})
                } catch (e) {
                    throw M.create("failed-service-worker-registration", {
                        browserErrorMessage: null == e ? void 0 : e.message
                    })
                }
            }
            async function Ue(e, t) {
                if (!navigator) throw M.create("only-available-in-window");
                if ("default" === Notification.permission && await Notification.requestPermission(), "granted" !== Notification.permission) throw M.create("permission-blocked");
                var n = e,
                    i = (await ((i = null == t ? void 0 : t.vapidKey) ? n.vapidKey = i : n.vapidKey || (n.vapidKey = ke)), e),
                    n = null == t ? void 0 : t.serviceWorkerRegistration;
                if (n || i.swRegistration || await $e(i), n || !i.swRegistration) {
                    if (!(n instanceof ServiceWorkerRegistration)) throw M.create("invalid-sw-registration");
                    i.swRegistration = n
                }
                return await 0, async function(e) {
                    o = e.swRegistration, i = e.vapidKey;
                    var i, t, n, a, r, o = await (await o.pushManager.getSubscription() || o.pushManager.subscribe({
                            userVisibleOnly: !0,
                            applicationServerKey: function() {
                                var e = (i + "=".repeat((4 - i.length % 4) % 4)).replace(/\-/g, "+").replace(/_/g, "/"),
                                    t = atob(e),
                                    n = new Uint8Array(t.length);
                                for (let e = 0; e < t.length; ++e) n[e] = t.charCodeAt(e);
                                return n
                            }()
                        })),
                        o = {
                            vapidKey: e.vapidKey,
                            swScope: e.swRegistration.scope,
                            endpoint: o.endpoint,
                            auth: P(o.getKey("auth")),
                            p256dh: P(o.getKey("p256dh"))
                        },
                        s = await Ee(e.firebaseDependencies);
                    if (s) {
                        if (r = s.subscriptionOptions, t = o.vapidKey === r.vapidKey, n = o.endpoint === r.endpoint, a = o.auth === r.auth, r = o.p256dh === r.p256dh, t && n && a && r) return Date.now() >= s.createTime + Be ? async function(e, t) {
                            try {
                                var n = await async function(e, t) {
                                        var n = await xe(e),
                                            i = Le(t.subscriptionOptions),
                                            i = {
                                                method: "PATCH",
                                                headers: n,
                                                body: JSON.stringify(i)
                                            };
                                        let a;
                                        try {
                                            var r = await fetch(Ne(e.appConfig) + "/" + t.token, i);
                                            a = await r.json()
                                        } catch (e) {
                                            throw M.create("token-update-failed", {
                                                errorInfo: null == e ? void 0 : e.toString()
                                            })
                                        }
                                        if (a.error) throw i = a.error.message, M.create("token-update-failed", {
                                            errorInfo: i
                                        });
                                        if (a.token) return a.token;
                                        throw M.create("token-update-no-token")
                                    }(e.firebaseDependencies, t),
                                    i = Object.assign(Object.assign({}, t), {
                                        token: n,
                                        createTime: Date.now()
                                    });
                                return await Me(e.firebaseDependencies, i), n
                            } catch (t) {
                                throw await Fe(e), t
                            }
                        }(e, {
                            token: s.token,
                            createTime: Date.now(),
                            subscriptionOptions: o
                        }) : s.token;
                        try {
                            await Ke(e.firebaseDependencies, s.token)
                        } catch (e) {
                            console.warn(e)
                        }
                    }
                    return He(e.firebaseDependencies, o)
                }(e)
            }
            async function Ge(e, t) {
                var n, i, a = t.data;
                a.isFirebaseMessaging && (e.onMessageHandler && a.messageType === w.PUSH_RECEIVED && ("function" == typeof e.onMessageHandler ? e.onMessageHandler(Re(a)) : e.onMessageHandler.next(Re(a))), "object" == typeof(t = n = a.data)) && t && Se in t && "1" === n[Te] && (t = e, i = a.messageType, e = n, a = function() {
                    switch (i) {
                        case w.NOTIFICATION_CLICKED:
                            return "notification_open";
                        case w.PUSH_RECEIVED:
                            return "notification_foreground";
                        default:
                            throw new Error
                    }
                }(), await !(await t.firebaseDependencies.analyticsProvider.get()).logEvent(a, {
                    message_id: e[Se],
                    message_name: e["google.c.a.c_l"],
                    message_time: e["google.c.a.ts"],
                    message_device_time: Math.floor(Date.now() / 1e3)
                }))
            }
            y = "@firebase/messaging";
            It._registerComponent(new t("messaging", e => {
                const t = new We(e.getProvider("app").getImmediate(), e.getProvider("installations-internal").getImmediate(), e.getProvider("analytics-internal"));
                return navigator.serviceWorker.addEventListener("message", e => Ge(t, e)), t
            }, "PUBLIC")), It._registerComponent(new t("messaging-internal", e => {
                const t = e.getProvider("messaging").getImmediate();
                return {
                    getToken: e => Ue(t, e)
                }
            }, "PRIVATE")), It.registerVersion(y, "0.12.4"), It.registerVersion(y, "0.12.4", "esm2017");
            const Je = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4",
                ze = "https://fcmregistrations.googleapis.com/v1",
                Ye = "FCM_MSG",
                Qe = "google.c.a.c_id",
                Ze = 3,
                Xe = 1;

            function A(e) {
                e = new Uint8Array(e);
                return btoa(String.fromCharCode(...e)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
            }(b = h = h || {})[b.DATA_MESSAGE = 1] = "DATA_MESSAGE", b[b.DISPLAY_NOTIFICATION = 3] = "DISPLAY_NOTIFICATION", (b = m = m || {}).PUSH_RECEIVED = "push-received", b.NOTIFICATION_CLICKED = "notification-clicked";
            const et = "fcm_token_details_db",
                tt = "fcm_token_object_Store";
            const nt = "firebase-messaging-database",
                it = 1,
                K = "firebase-messaging-store";
            let at = null;

            function rt() {
                return at = at || l(nt, it, {
                    upgrade: (e, t) => {
                        0 === t && e.createObjectStore(K)
                    }
                })
            }
            async function ot(e) {
                var t = ct(e);
                return (t = await (await rt()).transaction(K).objectStore(K).get(t)) || ((t = await async function(r) {
                    if ("databases" in indexedDB && !(await indexedDB.databases()).map(e => e.name).includes(et)) return null;
                    let o = null;
                    return (await l(et, 5, {
                            upgrade: async(e, t, n, i) => {
                                var a;
                                t < 2 || !e.objectStoreNames.contains(tt) || (i = await (e = i.objectStore(tt)).index("fcmSenderId").get(r), await e.clear(), i && (2 === t ? (a = i).auth && a.p256dh && a.endpoint && (o = {
                                    token: a.fcmToken,
                                    createTime: null != (e = a.createTime) ? e : Date.now(),
                                    subscriptionOptions: {
                                        auth: a.auth,
                                        p256dh: a.p256dh,
                                        endpoint: a.endpoint,
                                        swScope: a.swScope,
                                        vapidKey: "string" == typeof a.vapidKey ? a.vapidKey : A(a.vapidKey)
                                    }
                                }) : 3 === t ? (a = i, o = {
                                    token: a.fcmToken,
                                    createTime: a.createTime,
                                    subscriptionOptions: {
                                        auth: A(a.auth),
                                        p256dh: A(a.p256dh),
                                        endpoint: a.endpoint,
                                        swScope: a.swScope,
                                        vapidKey: A(a.vapidKey)
                                    }
                                }) : 4 === t && (o = {
                                    token: i.fcmToken,
                                    createTime: i.createTime,
                                    subscriptionOptions: {
                                        auth: A(i.auth),
                                        p256dh: A(i.p256dh),
                                        endpoint: i.endpoint,
                                        swScope: i.swScope,
                                        vapidKey: A(i.vapidKey)
                                    }
                                })))
                            }
                        })).close(), await f(et), await f("fcm_vapid_details_db"), await f("undefined"),
                        function(e) {
                            var t;
                            if (e && e.subscriptionOptions) return t = e.subscriptionOptions, "number" == typeof e.createTime && 0 < e.createTime && "string" == typeof e.token && 0 < e.token.length && "string" == typeof t.auth && 0 < t.auth.length && "string" == typeof t.p256dh && 0 < t.p256dh.length && "string" == typeof t.endpoint && 0 < t.endpoint.length && "string" == typeof t.swScope && 0 < t.swScope.length && "string" == typeof t.vapidKey && 0 < t.vapidKey.length
                        }(o) ? o : null
                }(e.appConfig.senderId)) ? (await st(e, t), t) : void 0)
            }
            async function st(e, t) {
                var e = ct(e),
                    n = (await rt()).transaction(K, "readwrite");
                return await n.objectStore(K).put(t, e), await n.done, t
            }

            function ct({
                appConfig: e
            }) {
                return e.appId
            }
            const N = new r("messaging", "Messaging", {
                "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
                "only-available-in-window": "This method is available in a Window context.",
                "only-available-in-sw": "This method is available in a service worker context.",
                "permission-default": "The notification permission was not granted and dismissed instead.",
                "permission-blocked": "The notification permission was not granted and blocked instead.",
                "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.",
                "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
                "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}",
                "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}",
                "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.",
                "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
                "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}",
                "token-update-no-token": "FCM returned no token when updating the user to push.",
                "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
                "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
                "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.",
                "invalid-vapid-key": "The public VAPID key must be a string.",
                "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
            });
            async function pt(e, t) {
                var n = {
                    method: "DELETE",
                    headers: await ut(e)
                };
                try {
                    var i, a = await (await fetch(dt(e.appConfig) + "/" + t, n)).json();
                    if (a.error) throw i = a.error.message, N.create("token-unsubscribe-failed", {
                        errorInfo: i
                    })
                } catch (e) {
                    throw N.create("token-unsubscribe-failed", {
                        errorInfo: null == e ? void 0 : e.toString()
                    })
                }
            }

            function dt({
                projectId: e
            }) {
                return ze + `/projects/${e}/registrations`
            }
            async function ut({
                appConfig: e,
                installations: t
            }) {
                t = await t.getToken();
                return new Headers({
                    "Content-Type": "application/json",
                    Accept: "application/json",
                    "x-goog-api-key": e.apiKey,
                    "x-goog-firebase-installations-auth": "FIS " + t
                })
            }

            function lt({
                p256dh: e,
                auth: t,
                endpoint: n,
                vapidKey: i
            }) {
                n = {
                    web: {
                        endpoint: n,
                        auth: t,
                        p256dh: e
                    }
                };
                return i !== Je && (n.web.applicationPubKey = i), n
            }
            async function ft(e) {
                var t, n = await ot(e.firebaseDependencies),
                    n = (n && (await pt(e.firebaseDependencies, n.token), n = ct(n = e.firebaseDependencies), await (t = (await rt()).transaction(K, "readwrite")).objectStore(K).delete(n), await t.done), await e.swRegistration.pushManager.getSubscription());
                return !n || n.unsubscribe()
            }
            async function gt(e, t) {
                t = {
                    token: await async function(e, t) {
                        var n = await ut(e),
                            t = lt(t),
                            t = {
                                method: "POST",
                                headers: n,
                                body: JSON.stringify(t)
                            };
                        let i;
                        try {
                            var a = await fetch(dt(e.appConfig), t);
                            i = await a.json()
                        } catch (e) {
                            throw N.create("token-subscribe-failed", {
                                errorInfo: null == e ? void 0 : e.toString()
                            })
                        }
                        if (i.error) throw t = i.error.message, N.create("token-subscribe-failed", {
                            errorInfo: t
                        });
                        if (i.token) return i.token;
                        throw N.create("token-subscribe-no-token")
                    }(e, t),
                    createTime: Date.now(),
                    subscriptionOptions: t
                };
                return await st(e, t), t.token
            }

            function wt(t, n) {
                var i = [];
                for (let e = 0; e < t.length; e++) i.push(t.charAt(e)), e < n.length && i.push(n.charAt(e));
                i.join("")
            }
            async function ht(e, t) {
                var n, i, a, r = function({
                    data: e
                }) {
                    if (!e) return null;
                    try {
                        return e.json()
                    } catch (e) {
                        return null
                    }
                }(e);
                if (r) {
                    t.deliveryMetricsExportedToBigQueryEnabled && (d = d = r, a = await (i = t).firebaseDependencies.installations.getId(), u = {}, d.from && (u.project_number = d.from), d.fcmMessageId && (u.message_id = d.fcmMessageId), u.instance_id = a, d.notification ? u.message_type = h.DISPLAY_NOTIFICATION.toString() : u.message_type = h.DATA_MESSAGE.toString(), u.sdk_platform = Ze.toString(), u.package_name = self.origin.replace(/(^\w+:|^)\/\//, ""), d.collapse_key && (u.collapse_key = d.collapse_key), u.event = Xe.toString(), null != (a = d.fcmOptions) && a.analytics_label && (u.analytics_label = null == (a = d.fcmOptions) ? void 0 : a.analytics_label), a = i, u = d = u, (i = {}).event_time_ms = Math.floor(Date.now()).toString(), i.source_extension_json_proto3 = JSON.stringify(u), await !a.logEvents.push(i));
                    var o, s, c, p, d = await mt();
                    if (d.some(e => "visible" === e.visibilityState && !e.url.startsWith("chrome-extension://"))) {
                        var u = d,
                            l = r;
                        l.isFirebaseMessaging = !0, l.messageType = m.PUSH_RECEIVED;
                        for (const f of u) f.postMessage(l)
                    } else r.notification && (a = r, (i = Object.assign({}, a.notification)).data = {
                        [Ye]: a
                    }, o = (n = i).actions, p = Notification.maxActions, o && p && o.length > p && console.warn(`This browser only supports ${p} actions. The remaining actions will not be displayed.`), await self.registration.showNotification(null != (p = n.title) ? p : "", n)), t && t.onBackgroundMessageHandler && (d = p = {
                        from: (o = r).from,
                        collapseKey: o.collapse_key,
                        messageId: o.fcmMessageId
                    }, (e = o).notification && (d.notification = {}, (r = e.notification.title) && (d.notification.title = r), (r = e.notification.body) && (d.notification.body = r), (r = e.notification.image) && (d.notification.image = r), r = e.notification.icon) && (d.notification.icon = r), e = p, (d = o).data && (e.data = d.data), d = p, (o.fcmOptions || null != (s = o.notification) && s.click_action) && (d.fcmOptions = {}, (c = null != (s = null == (s = o.fcmOptions) ? void 0 : s.link) ? s : null == (c = o.notification) ? void 0 : c.click_action) && (d.fcmOptions.link = c), c = null == (c = o.fcmOptions) ? void 0 : c.analytics_label) && (d.fcmOptions.analyticsLabel = c), "function" == typeof t.onBackgroundMessageHandler ? await t.onBackgroundMessageHandler(p) : t.onBackgroundMessageHandler.next(p))
                }
            }

            function mt() {
                return self.clients.matchAll({
                    type: "window",
                    includeUncontrolled: !0
                })
            }

            function bt(e) {
                return N.create("missing-app-config-values", {
                    valueName: e
                })
            }
            wt("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o"), wt("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");
            class vt {
                constructor(e, t, n) {
                    this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1;
                    var i = function(e) {
                        if (!e || !e.options) throw bt("App Configuration Object");
                        if (!e.name) throw bt("App Name");
                        var t = e.options;
                        for (const n of ["projectId", "apiKey", "appId", "messagingSenderId"])
                            if (!t[n]) throw bt(n);
                        return {
                            appName: e.name,
                            projectId: t.projectId,
                            apiKey: t.apiKey,
                            appId: t.appId,
                            senderId: t.messagingSenderId
                        }
                    }(e);
                    this.firebaseDependencies = {
                        app: e,
                        appConfig: i,
                        installations: t,
                        analyticsProvider: n
                    }
                }
                _delete() {
                    return Promise.resolve()
                }
            }
            It._registerComponent(new t("messaging-sw", e => {
                const t = new vt(e.getProvider("app").getImmediate(), e.getProvider("installations-internal").getImmediate(), e.getProvider("analytics-internal"));
                return self.addEventListener("push", e => {
                    e.waitUntil(ht(e, t))
                }), self.addEventListener("pushsubscriptionchange", e => {
                    e.waitUntil(async function(e, t) {
                        if (e.newSubscription) {
                            e = await ot(t.firebaseDependencies), await ft(t), t.vapidKey = null != (e = null == (e = null == e ? void 0 : e.subscriptionOptions) ? void 0 : e.vapidKey) ? e : Je;
                            var n = t;
                            e = n.swRegistration, i = n.vapidKey;
                            var i, a, r, o, s, e = await (await e.pushManager.getSubscription() || e.pushManager.subscribe({
                                    userVisibleOnly: !0,
                                    applicationServerKey: function() {
                                        var e = (i + "=".repeat((4 - i.length % 4) % 4)).replace(/\-/g, "+").replace(/_/g, "/"),
                                            t = atob(e),
                                            n = new Uint8Array(t.length);
                                        for (let e = 0; e < t.length; ++e) n[e] = t.charCodeAt(e);
                                        return n
                                    }()
                                })),
                                e = {
                                    vapidKey: n.vapidKey,
                                    swScope: n.swRegistration.scope,
                                    endpoint: e.endpoint,
                                    auth: A(e.getKey("auth")),
                                    p256dh: A(e.getKey("p256dh"))
                                },
                                c = await ot(n.firebaseDependencies);
                            if (c) {
                                if (s = c.subscriptionOptions, a = e.vapidKey === s.vapidKey, r = e.endpoint === s.endpoint, o = e.auth === s.auth, s = e.p256dh === s.p256dh, a && r && o && s) return void await (Date.now() >= c.createTime + 6048e5 ? async function(e, t) {
                                    try {
                                        var n = await async function(e, t) {
                                                var n = await ut(e),
                                                    i = lt(t.subscriptionOptions),
                                                    i = {
                                                        method: "PATCH",
                                                        headers: n,
                                                        body: JSON.stringify(i)
                                                    };
                                                let a;
                                                try {
                                                    var r = await fetch(dt(e.appConfig) + "/" + t.token, i);
                                                    a = await r.json()
                                                } catch (e) {
                                                    throw N.create("token-update-failed", {
                                                        errorInfo: null == e ? void 0 : e.toString()
                                                    })
                                                }
                                                if (a.error) throw i = a.error.message, N.create("token-update-failed", {
                                                    errorInfo: i
                                                });
                                                if (a.token) return a.token;
                                                throw N.create("token-update-no-token")
                                            }(e.firebaseDependencies, t),
                                            i = Object.assign(Object.assign({}, t), {
                                                token: n,
                                                createTime: Date.now()
                                            });
                                        return await st(e.firebaseDependencies, i), n
                                    } catch (t) {
                                        throw await ft(e), t
                                    }
                                }(n, {
                                    token: c.token,
                                    createTime: Date.now(),
                                    subscriptionOptions: e
                                }) : c.token);
                                try {
                                    await pt(n.firebaseDependencies, c.token)
                                } catch (n) {
                                    console.warn(n)
                                }
                            }
                            await gt(n.firebaseDependencies, e)
                        } else await ft(t)
                    }(e, t))
                }), self.addEventListener("notificationclick", e => {
                    e.waitUntil(async function(e) {
                        var t = null == (a = null == (i = e.notification) ? void 0 : i.data) ? void 0 : a[Ye];
                        if (t && !e.action) {
                            e.stopImmediatePropagation(), e.notification.close();
                            var n = (n = null != (e = null == (e = t.fcmOptions) ? void 0 : e.link) ? e : null == (n = t.notification) ? void 0 : n.click_action) || ("object" == typeof(e = t.data) && e && Qe in e ? self.location.origin : null);
                            if (n) {
                                var i = new URL(n, self.location.href),
                                    a = new URL(self.location.origin);
                                if (i.host === a.host) {
                                    let e = await async function(e) {
                                        for (const n of await mt()) {
                                            var t = new URL(n.url, self.location.href);
                                            if (e.host === t.host) return n
                                        }
                                        return null
                                    }(i);
                                    if (e ? e = await e.focus() : (e = await self.clients.openWindow(n), await new Promise(e => {
                                            setTimeout(e, 3e3)
                                        })), e) return t.messageType = m.NOTIFICATION_CLICKED, t.isFirebaseMessaging = !0, e.postMessage(t)
                                }
                            }
                        }
                    }(e))
                }), t
            }, "PUBLIC"));
            class yt {
                constructor(e, t) {
                    this.app = e, this._delegate = t, this.app = e, this._delegate = t
                }
                async getToken(t) {
                    return async function(e) {
                        return Ue(o(e), t)
                    }(this._delegate)
                }
                async deleteToken() {
                    return async function(e) {
                        if (navigator) return e.swRegistration || await $e(e), Fe(e);
                        throw M.create("only-available-in-window")
                    }(o(this._delegate))
                }
                onMessage(e) {
                    var t = this._delegate,
                        n = t = o(t);
                    if (navigator) return n.onMessageHandler = e, () => {
                        n.onMessageHandler = null
                    };
                    throw M.create("only-available-in-window")
                }
                onBackgroundMessage(e) {
                    var t = this._delegate,
                        n = t = o(t),
                        t = e;
                    if (void 0 !== self.document) throw N.create("only-available-in-sw");
                    return n.onBackgroundMessageHandler = t, () => {
                        n.onBackgroundMessageHandler = null
                    }
                }
            }
            v = {
                isSupported: function() {
                    return self && "ServiceWorkerGlobalScope" in self ? x() && "PushManager" in self && "Notification" in self && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey") : "undefined" != typeof window && x() && !("undefined" == typeof navigator || !navigator.cookieEnabled) && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey")
                }
            };
            e.default.INTERNAL.registerComponent(new t("messaging-compat", e => self && "ServiceWorkerGlobalScope" in self ? new yt(e.getProvider("app-compat").getImmediate(), e.getProvider("messaging-sw").getImmediate()) : new yt(e.getProvider("app-compat").getImmediate(), e.getProvider("messaging").getImmediate()), "PUBLIC").setServiceProps(v)), e.default.registerVersion("@firebase/messaging-compat", "0.2.4")
        }.apply(this, arguments)
    } catch (e) {
        throw console.error(e), new Error("Cannot instantiate firebase-messaging-compat.js - be sure to load firebase-app.js first.")
    }
});
